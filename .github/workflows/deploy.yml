name: CD Pipeline - Deploy to Server

# This workflow deploys the application to your personal server
# It only runs after CI passes and on push to main branch

on:
  push:
    branches:
      - main  # Only deploy from main branch
    paths-ignore:
      - '**.md'  # Don't deploy on documentation changes
      - '.gitignore'
      - 'README.md'
  workflow_dispatch:  # Allow manual trigger from GitHub UI

# Prevent concurrent deployments
concurrency:
  group: deployment
  cancel-in-progress: false  # Wait for current deployment to finish

jobs:
  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    
    # Only run if CI pipeline passes (if it exists)
    # Uncomment if you want to require CI to pass first
    # needs: [build-and-test]
    
    steps:
      # Step 1: Checkout code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for git commands
      
      # Step 2: Display deployment info
      - name: Display deployment info
        run: |
          echo "üöÄ Starting deployment..."
          echo "üì¶ Repository: ${{ github.repository }}"
          echo "üîñ Branch: ${{ github.ref_name }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
      
      # Step 3: Set up SSH
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}
      
      # Step 4: Add server to known hosts
      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
      
      # Step 5: Test SSH connection
      - name: Test SSH connection
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo '‚úÖ SSH connection successful'"
      
      # Step 6: Create deployment script on server
      - name: Create deployment script
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            # Create deployment directory if it doesn't exist
            mkdir -p ${{ secrets.SERVER_DEPLOY_PATH }}
            
            # Create deployment script
            cat > ${{ secrets.SERVER_DEPLOY_PATH }}/deploy.sh << 'SCRIPT'
            #!/bin/bash
            set -e  # Exit on error
            
            echo "üöÄ Starting deployment..."
            echo "üìÖ Date: $(date)"
            echo "üì¶ Commit: $1"
            
            # Navigate to backend directory
            cd ${{ secrets.SERVER_DEPLOY_PATH }}/civildesk-backend
            
            # Pull latest changes
            echo "üì• Pulling latest changes..."
            git fetch origin
            git reset --hard origin/main
            git clean -fd
            
            # Show current commit
            echo "üìù Current commit: $(git rev-parse HEAD)"
            echo "üìù Commit message: $(git log -1 --pretty=%B)"
            
            # Backup current deployment (optional)
            echo "üíæ Creating backup..."
            if [ -f docker-compose.yml ]; then
              docker compose ps > /tmp/civildesk_backup_status.txt 2>&1 || true
            fi
            
            # Stop old containers gracefully
            echo "üõë Stopping old containers..."
            docker compose down --timeout 30 || true
            
            # Build new Docker image
            echo "üî® Building new Docker image..."
            docker compose build --no-cache --pull
            
            # Start new containers
            echo "‚ñ∂Ô∏è  Starting new containers..."
            docker compose up -d
            
            # Wait for services to be healthy
            echo "‚è≥ Waiting for services to start..."
            sleep 15
            
            # Health check
            echo "üè• Running health check..."
            MAX_RETRIES=10
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f -s http://localhost:8080/api/health > /dev/null 2>&1; then
                echo "‚úÖ Health check passed!"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                echo "‚è≥ Health check attempt $RETRY_COUNT/$MAX_RETRIES failed, retrying..."
                sleep 5
              fi
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "‚ùå Health check failed after $MAX_RETRIES attempts!"
              echo "üìã Container logs:"
              docker compose logs --tail=50 backend
              exit 1
            fi
            
            # Show container status
            echo "üìä Container status:"
            docker compose ps
            
            # Clean up old images (optional - saves disk space)
            echo "üßπ Cleaning up old Docker images..."
            docker image prune -f || true
            
            echo "‚úÖ Deployment completed successfully!"
            SCRIPT
            
            # Make script executable
            chmod +x ${{ secrets.SERVER_DEPLOY_PATH }}/deploy.sh
            echo "‚úÖ Deployment script created"
          EOF
      
      # Step 7: Execute deployment
      - name: Execute deployment
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "${{ secrets.SERVER_DEPLOY_PATH }}/deploy.sh ${{ github.sha }}"
      
      # Step 8: Verify deployment
      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          sleep 5
          
          # Check if application is responding
          HTTP_CODE=$(ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "curl -s -o /dev/null -w '%{http_code}' http://localhost:8080/api/health" || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Deployment verified! Application is healthy."
          else
            echo "‚ö†Ô∏è  Warning: Health check returned HTTP $HTTP_CODE"
            echo "Please verify manually: http://${{ secrets.SERVER_HOST }}:8080/api/health"
          fi
      
      # Step 9: Get container logs (for debugging)
      - name: Get container logs
        if: failure()
        run: |
          echo "üìã Fetching container logs..."
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "cd ${{ secrets.SERVER_DEPLOY_PATH }}/civildesk-backend && docker compose logs --tail=100 backend" || true
      
      # Step 10: Deployment summary
      - name: Deployment summary
        if: success()
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "üåê Application URL: http://${{ secrets.SERVER_HOST }}:8080"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Deployed by: ${{ github.actor }}"
      
      # Step 11: Rollback on failure (optional)
      - name: Rollback on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed! Attempting rollback..."
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF' || true
            cd ${{ secrets.SERVER_DEPLOY_PATH }}/civildesk-backend
            
            # Restore previous version
            echo "üîÑ Rolling back to previous commit..."
            git reset --hard HEAD~1 || true
            docker compose down
            docker compose up -d
            
            echo "‚úÖ Rollback completed"
          EOF

